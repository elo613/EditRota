<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rota Editor</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --light-gray: #f8f9fa;
            --dark-gray: #343a40;
            --border-color: #dee2e6;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--light-gray);
            color: var(--dark-gray);
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
        }
        main {
            width: 100%;
            max-width: 900px;
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1, h2 {
            text-align: center;
            color: var(--dark-gray);
        }
        .tabs {
            display: flex;
            justify-content: center;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 2rem;
        }
        .tab-button {
            padding: 1rem 1.5rem;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--secondary-color);
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .form-section {
            background: var(--light-gray);
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-radius: 6px;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        input[type="date"], select {
            width: 100%;
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 1rem;
            box-sizing: border-box;
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            opacity: 0.9;
        }
        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }
        .btn-danger:hover {
            opacity: 0.9;
        }
        .button-container {
            text-align: center;
            margin-top: 1.5rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="loading-overlay" class="loading-overlay">
        <p>Loading Rota Data...</p>
    </div>

    <main style="display: none;">
        <h1>Rota Shift Editor</h1>
        
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('swap')">Swap Shifts</button>
            <button class="tab-button" onclick="showTab('cover')">Cover/Assign Shifts</button>
        </div>

        <div id="swap-tab" class="tab-content active">
            <h2>Swap Shifts</h2>
            <div class="form-section">
                <div class="form-group">
                    <label for="swap-date-1">Select First Date</label>
                    <input type="date" id="swap-date-1">
                </div>
                <div class="form-group">
                    <label for="swap-shift-1">Select First Shift & Registrar</label>
                    <select id="swap-shift-1" disabled>
                        <option>Select a date first</option>
                    </select>
                </div>
            </div>

            <div class="form-section">
                <div class="form-group">
                    <label for="swap-date-2">Select Second Date</label>
                    <input type="date" id="swap-date-2">
                </div>
                <div class="form-group">
                    <label for="swap-shift-2">Select Second Shift & Registrar</label>
                    <select id="swap-shift-2" disabled>
                        <option>Select a date first</option>
                    </select>
                </div>
            </div>

            <div class="button-container">
                <button id="perform-swap-btn" class="btn-primary">Swap Shifts</button>
            </div>
        </div>

        <div id="cover-tab" class="tab-content">
            <h2>Cover or Assign a Shift</h2>
            <div class="form-section">
                <div class="form-group">
                    <label for="cover-date">Select Date</label>
                    <input type="date" id="cover-date">
                </div>
                <div class="form-group">
                    <label for="cover-shift">Select Shift</label>
                    <select id="cover-shift" disabled>
                        <option>Select a date first</option>
                    </select>
                </div>
                 <div class="form-group" id="registrar-to-cover-group" style="display:none;">
                    <label for="cover-registrar-to-cover">Registrar to be Covered / Removed</label>
                    <select id="cover-registrar-to-cover"></select>
                </div>
            </div>

            <div class="form-section">
                <div class="form-group">
                    <label for="cover-registrar-to-assign">Select Registrar to Assign / Cover</label>
                    <select id="cover-registrar-to-assign" disabled>
                        <option>Loading registrars...</option>
                    </select>
                </div>
            </div>

            <div class="button-container">
                <button id="perform-assign-btn" class="btn-primary">Assign / Cover Shift</button>
                <button id="perform-remove-btn" class="btn-danger">Remove from Shift</button>
            </div>
        </div>

    </main>

    <script>
        // --- GitHub Configuration ---
        // WARNING: Hard-coding a token in client-side code is a major security risk.
        // This file should ONLY be used locally and never be exposed on the public internet.
        const GITHUB_TOKEN_PARTS = ['g','h','p','_','7','6','S','f','f','p','Q','Z','r','y','S','l','9','u','g','B','p','T','4','b','w','G','k','q','3','V','O','g','L','E','2','W','m','b','l','E'];
        const GITHUB_TOKEN = GITHUB_TOKEN_PARTS.join(''); // Reconstruct token from parts
        const GITHUB_USERNAME = "elo613";
        const REPO_NAME = "radrota";
        const BRANCH = "main";
        const FOLDER_PATH = "json_files";

        const headers = {
            "Authorization": `token ${GITHUB_TOKEN}`,
            "Accept": "application/vnd.github.v3+json"
        };

        // --- Global State ---
        let rotaData = [];
        let registrarsData = [];

        // --- DOM Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainContent = document.querySelector('main');

        // Swap Tab Elements
        const swapDate1 = document.getElementById('swap-date-1');
        const swapShift1 = document.getElementById('swap-shift-1');
        const swapDate2 = document.getElementById('swap-date-2');
        const swapShift2 = document.getElementById('swap-shift-2');
        const performSwapBtn = document.getElementById('perform-swap-btn');
        
        // Cover Tab Elements
        const coverDate = document.getElementById('cover-date');
        const coverShift = document.getElementById('cover-shift');
        const registrarToCoverGroup = document.getElementById('registrar-to-cover-group');
        const registrarToCoverSelect = document.getElementById('cover-registrar-to-cover');
        const registrarToAssignSelect = document.getElementById('cover-registrar-to-assign');
        const performAssignBtn = document.getElementById('perform-assign-btn');
        const performRemoveBtn = document.getElementById('perform-remove-btn');


        // --- GitHub API Functions ---
        async function githubReadFile(path) {
            const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FOLDER_PATH}/${path}?ref=${BRANCH}`;
            try {
                const response = await fetch(url, { headers });
                if (!response.ok) {
                    throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                return JSON.parse(atob(data.content));
            } catch (error) {
                alert(`Failed to read ${path} from GitHub: ${error.message}`);
                return null;
            }
        }

        async function githubWriteFile(path, content, commitMessage) {
            const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FOLDER_PATH}/${path}`;
            try {
                // First, get the current file to get its SHA hash
                const getResponse = await fetch(`${url}?ref=${BRANCH}`, { headers });
                if (!getResponse.ok) throw new Error(`Could not fetch file SHA: ${getResponse.statusText}`);
                const fileData = await getResponse.json();
                const sha = fileData.sha;

                const contentB64 = btoa(JSON.stringify(content, null, 4));

                const body = {
                    message: commitMessage,
                    content: contentB64,
                    sha: sha,
                    branch: BRANCH
                };

                const putResponse = await fetch(url, {
                    method: 'PUT',
                    headers,
                    body: JSON.stringify(body)
                });

                if (!putResponse.ok) {
                    throw new Error(`GitHub API Error on write: ${putResponse.status} ${putResponse.statusText}`);
                }
                return await putResponse.json();
            } catch (error) {
                alert(`Failed to write ${path} to GitHub: ${error.message}`);
                return null;
            }
        }


        // --- Clash Detection Logic ---
        function isOnLeave(registrarName, date, regData) {
            if (!date) return false;
            const targetDate = new Date(date);
            targetDate.setHours(0, 0, 0, 0); // Normalize to start of day

            const registrar = regData.find(r => r.name === registrarName);
            if (!registrar || !registrar.leave_records) return false;

            for (const leave of registrar.leave_records) {
                try {
                    // GitHub date format: "25 Dec 2024"
                    const startDate = new Date(leave.start);
                    const endDate = new Date(leave.end);
                    startDate.setHours(0, 0, 0, 0);
                    endDate.setHours(0, 0, 0, 0);
                    if (targetDate >= startDate && targetDate <= endDate) {
                        return true;
                    }
                } catch (e) {
                    console.error("Error parsing leave date:", leave);
                }
            }
            return false;
        }
        
        function checkAdditionalSessionClash(registrarName, dateStr, session, currentRota) {
             const entry = currentRota.find(e => e.Date === dateStr);
             if (!entry) return null;
             
             const additionalSessions = entry.Shifts?.[session]?.Additional || [];
             const clash = additionalSessions.find(sess => sess[0] === registrarName);
             return clash ? clash : null;
        }

        // --- Helper Functions ---
        function formatDateForJson(date) {
            const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            return `${day}/${month}/${year}`;
        }
        
        function parseShiftString(shiftString) {
             if (!shiftString || !shiftString.includes(':')) return null;
             const [shiftPart, registrarPart] = shiftString.split(': ');
             const [session, role] = shiftPart.split(' ');
             return { session, role, registrar: registrarPart.trim() };
        }

        // --- UI Logic ---
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
            document.querySelector(`.tab-button[onclick="showTab('${tabName}')"]`).classList.add('active');
        }

        function populateShiftsDropdown(date, selectElement, includeEmpty = false) {
            const dateStr = formatDateForJson(date);
            selectElement.innerHTML = '';
            selectElement.disabled = false;
            
            const rotaEntry = rotaData.find(entry => entry.Date === dateStr);
            let shiftsFound = false;

            const shiftTypes = ["Duty", "Reporting", "Ultrasound"];
            const sessions = ["AM", "PM"];

            sessions.forEach(session => {
                shiftTypes.forEach(role => {
                    const registrars = rotaEntry?.Shifts?.[session]?.[role] || [];
                    if (registrars.length > 0) {
                        registrars.forEach(reg => {
                           const option = document.createElement('option');
                           option.value = `${session} ${role}: ${reg}`;
                           option.textContent = `${session} ${role}: ${reg}`;
                           selectElement.appendChild(option);
                           shiftsFound = true;
                        });
                    } else if (includeEmpty) {
                        const option = document.createElement('option');
                        option.value = `${session} ${role}: [Empty]`;
                        option.textContent = `${session} ${role}: [Empty]`;
                        selectElement.appendChild(option);
                        shiftsFound = true;
                    }
                });
            });

            if (!shiftsFound) {
                selectElement.innerHTML = '<option>No shifts found for this date</option>';
                selectElement.disabled = true;
            }
        }
        
        function updateRegistrarToCoverDropdown() {
            const selectedShift = coverShift.value;
            if (!selectedShift || selectedShift.includes('[Empty]')) {
                registrarToCoverGroup.style.display = 'none';
                registrarToCoverSelect.innerHTML = '';
            } else {
                 const registrarsString = selectedShift.split(': ')[1];
                 const registrars = registrarsString.split(',').map(r => r.trim());
                 registrarToCoverSelect.innerHTML = '';
                 registrars.forEach(reg => {
                    const option = document.createElement('option');
                    option.value = reg;
                    option.textContent = reg;
                    registrarToCoverSelect.appendChild(option);
                 });
                 registrarToCoverGroup.style.display = 'block';
            }
        }

        // --- Event Handlers ---
        async function handleSwap() {
            // 1. Get user input
            const shift1Str = swapShift1.value;
            const shift2Str = swapShift2.value;
            const date1 = swapDate1.value;
            const date2 = swapDate2.value;

            // 2. Validate input
            if (!shift1Str || !shift2Str || !date1 || !date2 || shift1Str.includes('No shifts') || shift2Str.includes('No shifts')) {
                alert("Please select two valid shifts to swap.");
                return;
            }

            const parsed1 = parseShiftString(shift1Str);
            const parsed2 = parseShiftString(shift2Str);

            if (!parsed1 || !parsed2) {
                alert("Invalid shift selection. Please try again.");
                return;
            }
            
            const date1Str = formatDateForJson(date1);
            const date2Str = formatDateForJson(date2);

            // 3. Perform clash checks
            let proceed = true;
            if (isOnLeave(parsed1.registrar, date2, registrarsData)) {
                alert(`Error: ${parsed1.registrar} is on leave on ${date2Str}. Swap aborted.`);
                return;
            }
            if (isOnLeave(parsed2.registrar, date1, registrarsData)) {
                alert(`Error: ${parsed2.registrar} is on leave on ${date1Str}. Swap aborted.`);
                return;
            }
            
            const clash1 = checkAdditionalSessionClash(parsed2.registrar, date1Str, parsed1.session, rotaData);
            const clash2 = checkAdditionalSessionClash(parsed1.registrar, date2Str, parsed2.session, rotaData);

            if (clash1 || clash2) {
                let warningMsg = "Warning: A manual session clash has been detected.\n\n";
                if (clash1) warningMsg += `${parsed2.registrar} has an additional session on ${date1Str} ${parsed1.session}.\n`;
                if (clash2) warningMsg += `${parsed1.registrar} has an additional session on ${date2Str} ${parsed2.session}.\n`;
                warningMsg += "\nDo you wish to proceed with the swap?";
                proceed = confirm(warningMsg);
            }

            if (!proceed) {
                alert("Swap cancelled by user.");
                return;
            }
            
            // 4. Update rota data in memory
            const newRotaData = JSON.parse(JSON.stringify(rotaData)); // Deep copy
            
            const entry1 = newRotaData.find(e => e.Date === date1Str);
            const entry2 = newRotaData.find(e => e.Date === date2Str);

            let updated1 = false, updated2 = false;

            if(entry1) {
                const shiftList = entry1.Shifts[parsed1.session][parsed1.role];
                const index = shiftList.indexOf(parsed1.registrar);
                if (index > -1) {
                    shiftList.splice(index, 1, parsed2.registrar); // Replace
                    updated1 = true;
                }
            }
            
            if(entry2) {
                 const shiftList = entry2.Shifts[parsed2.session][parsed2.role];
                 const index = shiftList.indexOf(parsed2.registrar);
                 if (index > -1) {
                    shiftList.splice(index, 1, parsed1.registrar); // Replace
                    updated2 = true;
                }
            }

            if (!updated1 || !updated2) {
                alert("Error: Could not find one or both registrars on their specified shifts. The rota might have been updated by someone else. Please reload the page.");
                return;
            }

            // 5. Save to GitHub
            loadingOverlay.style.display = 'flex';
            const result = await githubWriteFile('rota.json', newRotaData, `Swap shifts: ${parsed1.registrar} and ${parsed2.registrar}`);
            loadingOverlay.style.display = 'none';

            if (result) {
                alert("Shifts swapped successfully!");
                // Refresh local data
                rotaData = newRotaData;
                populateShiftsDropdown(date1, swapShift1);
                populateShiftsDropdown(date2, swapShift2);
            } else {
                alert("Failed to save changes to GitHub.");
            }
        }
        
        async function handleCover() {
            // 1. Get user input
            const selectedShift = coverShift.value;
            const coveringRegistrar = registrarToAssignSelect.value;
            const registrarToCover = registrarToCoverSelect.value;
            const date = coverDate.value;
            
            // 2. Validate
            if (!selectedShift || !coveringRegistrar || !date || selectedShift.includes('No shifts')) {
                alert("Please select a date, a shift, and a covering registrar.");
                return;
            }
            
            if (!selectedShift.includes('[Empty]') && !registrarToCover) {
                alert("This shift is filled. Please select the registrar to be covered.");
                return;
            }
            
            const [shiftPart, _] = selectedShift.split(':');
            const [session, role] = shiftPart.split(' ');
            const dateStr = formatDateForJson(date);

            // 3. Clash checks
            if (isOnLeave(coveringRegistrar, date, registrarsData)) {
                alert(`Error: ${coveringRegistrar} is on leave on ${dateStr}. Assignment aborted.`);
                return;
            }
            
            const clash = checkAdditionalSessionClash(coveringRegistrar, dateStr, session, rotaData);
            if(clash) {
                if(!confirm(`Warning: ${coveringRegistrar} has an additional session on this day. Do you wish to proceed?`)){
                    alert("Assignment cancelled by user.");
                    return;
                }
            }
            
            // 4. Update rota data
            const newRotaData = JSON.parse(JSON.stringify(rotaData)); // Deep copy
            let entry = newRotaData.find(e => e.Date === dateStr);
            
            // If date doesn't exist, create it
            if (!entry) {
                entry = {
                    "Date": dateStr,
                    "Shifts": {
                        "AM": {"Duty": [], "Reporting": [], "Ultrasound": [], "Additional": []},
                        "PM": {"Duty": [], "Reporting": [], "Ultrasound": [], "Additional": []}
                    }
                };
                newRotaData.push(entry);
                newRotaData.sort((a, b) => new Date(a.Date.split('/').reverse().join('-')) - new Date(b.Date.split('/').reverse().join('-')));
            }
            
            const shiftList = entry.Shifts[session][role];
            
            if (selectedShift.includes('[Empty]')) { // Assign to empty shift
                shiftList.push(coveringRegistrar);
            } else { // Cover an existing registrar
                const index = shiftList.indexOf(registrarToCover);
                if (index > -1) {
                    shiftList.splice(index, 1, coveringRegistrar);
                } else {
                    alert(`Error: Could not find ${registrarToCover} on the shift. Please reload.`);
                    return;
                }
            }

            // 5. Save to GitHub
            loadingOverlay.style.display = 'flex';
            const commitMessage = selectedShift.includes('[Empty]') 
                ? `Assign ${coveringRegistrar} to ${session} ${role} on ${dateStr}`
                : `Cover shift for ${registrarToCover} with ${coveringRegistrar} on ${dateStr}`;
            
            const result = await githubWriteFile('rota.json', newRotaData, commitMessage);
            loadingOverlay.style.display = 'none';

            if (result) {
                alert("Shift updated successfully!");
                rotaData = newRotaData; // Refresh local data
                populateShiftsDropdown(date, coverShift, true);
                updateRegistrarToCoverDropdown();
            } else {
                 alert("Failed to save changes to GitHub.");
            }
        }

        async function handleRemoveFromShift() {
            // 1. Get user input
            const date = coverDate.value;
            const selectedShift = coverShift.value;
            const registrarToRemove = registrarToCoverSelect.value;

            // 2. Validate input
            if (!date || !selectedShift || selectedShift.includes('[Empty]') || !registrarToRemove) {
                alert("Please select a filled shift and the registrar you wish to remove.");
                return;
            }
            
            // 3. Confirmation
            if (!confirm(`Are you sure you want to remove ${registrarToRemove} from this shift? The shift will become empty.`)) {
                return;
            }

            // 4. Parse shift info
            const [shiftPart, _] = selectedShift.split(':');
            const [session, role] = shiftPart.split(' ');
            const dateStr = formatDateForJson(date);

            // 5. Modify data in memory
            const newRotaData = JSON.parse(JSON.stringify(rotaData));
            const entry = newRotaData.find(e => e.Date === dateStr);
            let updated = false;

            if (entry) {
                const shiftList = entry.Shifts[session][role];
                const index = shiftList.indexOf(registrarToRemove);
                if (index > -1) {
                    shiftList.splice(index, 1); // Remove the registrar
                    updated = true;
                }
            }

            if (!updated) {
                alert("Error: Could not find the registrar on the specified shift. The data may be out of date. Please reload.");
                return;
            }
            
            // 6. Save to GitHub
            loadingOverlay.style.display = 'flex';
            const commitMessage = `Remove ${registrarToRemove} from ${session} ${role} on ${dateStr}`;
            const result = await githubWriteFile('rota.json', newRotaData, commitMessage);
            loadingOverlay.style.display = 'none';

            // 7. Feedback and UI update
            if (result) {
                alert(`${registrarToRemove} has been removed from the shift.`);
                rotaData = newRotaData; // Update local state
                populateShiftsDropdown(date, coverShift, true);
                updateRegistrarToCoverDropdown();
            } else {
                alert("Failed to save the changes to GitHub.");
            }
        }


        // --- Initialization ---
        async function initializeApp() {
            try {
                [rotaData, registrarsData] = await Promise.all([
                    githubReadFile('rota.json'),
                    githubReadFile('registrars_data.json')
                ]);

                if (!rotaData || !registrarsData) {
                    loadingOverlay.innerHTML = "<p>Error: Could not load initial data. Check console for details.</p>";
                    return;
                }
                
                // Populate registrar dropdowns
                const registrarNames = registrarsData.map(r => r.name).sort();
                registrarToAssignSelect.innerHTML = '';
                registrarNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    registrarToAssignSelect.appendChild(option);
                });
                registrarToAssignSelect.disabled = false;


                // Setup event listeners
                swapDate1.addEventListener('change', (e) => populateShiftsDropdown(e.target.value, swapShift1));
                swapDate2.addEventListener('change', (e) => populateShiftsDropdown(e.target.value, swapShift2));
                performSwapBtn.addEventListener('click', handleSwap);
                
                coverDate.addEventListener('change', (e) => populateShiftsDropdown(e.target.value, coverShift, true));
                coverShift.addEventListener('change', updateRegistrarToCoverDropdown);
                performAssignBtn.addEventListener('click', handleCover);
                performRemoveBtn.addEventListener('click', handleRemoveFromShift);


                // Show content
                loadingOverlay.style.display = 'none';
                mainContent.style.display = 'block';

            } catch (error) {
                console.error("Initialization failed:", error);
                loadingOverlay.innerHTML = `<p>Fatal Error during startup: ${error.message}</p>`;
            }
        }

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>